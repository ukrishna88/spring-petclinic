<div><br class="Apple-interchange-newline">pipeline {
    agent any
    tools {
        gradle 'Gradle'
        //nodejs 'NodeJS@16'
    }
    options {
        quietPeriod(10800) // Quiet period in seconds
    }
    parameters {
         choice(choices: ['Test' , 'Publish', 'Test & Publish', 'Sonarqube analysis', 'Black Duck Scanning'], description: '', name: 'advancedAction')
    }
    stages {
        stage("test") {
            when {
                 expression { params.advancedAction == 'Test' ||  params.advancedAction == 'Test & Publish'}
            }
            steps {
                echo 'Tests pipeline started'
                sh './gradlew test'
                echo 'Tests completed'
            }
        }

        stage("build") {
		when {
                 expression { params.advancedAction != 'Sonarqube analysis' }
             }
            steps {
                echo 'Build pipeline started'
                sh './gradlew -x test --refresh-dependencies clean build war'
                echo 'Build process completed'
            }
        }

        stage("deploy") {
            when {
                expression { params.advancedAction != 'Publish' && env.GIT_BRANCH == 'develop'}
            }
            steps {
                sshagent(credentials: ["${TARGET}"]) {
                    sh "scp build/libs/MYWORK.war ${SSH_USER}@${TARGET}:${TARGET_HOME}/EAR/"
                    sh "scp build/libs/MYWORK.zip ${SSH_USER}@${TARGET}:${TARGET_HOME}/EAR/"
                    sh "scp build/libs/Jars/conduit/*.jar ${SSH_USER}@${TARGET}:${CONDUIT_LOCATION}"
                    sh "scp build/libs/Jars/notifier/*.zip ${SSH_USER}@${TARGET}:${INSTANCE_JARS}"
                    sh "ssh ${USER}@${TARGET} '${TARGET_HOME}/scripts/stopServers.sh ${MYWORK_VM} && ${TARGET_HOME}/scripts/stopNotifers.sh'"
                    sh "ssh ${USER}@${TARGET} 'rm -rf ${INSTANCE_JARS_BACKUP} && mkdir ${INSTANCE_JARS_BACKUP} && mv ${INSTANCE_JARS}/*.jar ${INSTANCE_JARS_BACKUP} && unzip -o ${INSTANCE_JARS}/Notifier_Instances.zip -d ${INSTANCE_JARS} && rm ${INSTANCE_JARS}/*.zip'"
                    sh "ssh ${USER}@${TARGET} '${TARGET_HOME}/scripts/wasDeployApplication.sh && ${TARGET_HOME}/scripts/startServers.sh ${MYWORK_VM} && ${TARGET_HOME}/scripts/startNotifers.sh '"
                }
            }
        }

        stage('Black Duck Scanning') {
            when {
                expression { params.buildAction == 'Black Duck Scanning'}
            }
            steps {
                echo 'Black Duck Scan started'
                dir("${env.WORKSPACE}"){
                    sh "pwd"

                    synopsys_detect detectProperties: '''--blackduck.trust.cert=true  \\
                    --logging.level.com.synopsys.integration=debug \\
                    --detect.source.path=./ \\
                    --detect.excluded.directories.defaults.disabled=true \\
                    --detect.detector.search.depth=100 \\
                    --detect.excluded.directories.search.depth=100 \\
                    --detect.project.name=RTM_jenkins_job \\
                    --detect.project.version.name=v1 \\
                    --detect.report.timeout=3600 \\
                    --detect.wait.for.results=false \\
                    --detect.npm.include.dev.dependencies=false \\
                    --detect.npm.include.peer.dependencies=false \\
                    --detect.risk.report.pdf=true''', downloadStrategyOverride: [$class: 'ScriptOrJarDownloadStrategy']

                    echo 'Black Duck Scan completed'
                }
            }
        }

        stage("publish") {
            when {
                expression { params.advancedAction == 'Publish' ||  params.advancedAction == 'Test & Publish'}
            }
            steps {
                script {
                    def jFrog = Artifactory.server "${TARGET_ARTIFACTORY}"
                    def branchName = env.GIT_BRANCH
                    if(branchName == 'develop')
                        branchName = "${LATEST_BRANCH}"

                    targetFolder =  new Date().format("yyyyMMdd", TimeZone.getTimeZone('UTC')) + "/${branchName}"
                    version = "17.0.0"
                    def uploadSpec = """{
                          "files": [
                                {
                                  "pattern": "build/libs/Jars/conduit/*.jar",
                                  "target": "${ARTIFACTORY_BASE}/ztm/${version}/${targetFolder}/9_Jobs/"
                                },
                                {
                                  "pattern": "build/libs/*.war",
                                  "target": "${ARTIFACTORY_BASE}/ztm/${version}/${targetFolder}/2_WAR/"
                                },
                                {
                                  "pattern": "build/libs/*MYWORK.zip",
                                  "target": "${ARTIFACTORY_BASE}/ztm/${version}/${targetFolder}/3_StaticContents/"
                                },
                                {
                                  "pattern": "build/libs/Jars/notifier/*.zip",
                                   "target": "${ARTIFACTORY_BASE}/ztm/${version}/${targetFolder}/6_Notifier_Instances/"
                                },
                                {
                                  "pattern": "build/libs/Jars/utility/EtlUtility.jar",
                                   "target": "${ARTIFACTORY_BASE}/ztm/${version}/${targetFolder}/11_UtilityJars/SWA/"
                                }
                         ]
                    }"""
                    jFrog.upload spec: uploadSpec
                }
            }
        }
       stage('Sonarqube analysis') {
            when {
                expression { params.advancedAction == 'Sonarqube analysis' }
            }
            steps {
                echo 'SonarQube analysis started'
		withSonarQubeEnv(installationName: 'SonarQube', envOnly: true) {
      			sh "./gradlew sonarqube"
    		}
		echo 'SonarQube analysis completed'
                }
         }
    }	   
    post {
        success {
            office365ConnectorSend color: '#78b037', message: "SUCCESSFUL: Build #${env.BUILD_NUMBER}. GIT:${env.GIT_BRANCH}, SHA:${env.GIT_COMMIT}", status: 'SUCCESS',
               webhookUrl:"${TEAM_WEBHOOK}"
        }
        unstable {
            office365ConnectorSend color: '#f5a623', message: "UNSTABLE: Build #${env.BUILD_NUMBER}. GIT:${env.GIT_BRANCH}, SHA:${env.GIT_COMMIT}", status: 'UNSTABLE',
               webhookUrl:"${TEAM_WEBHOOK}"
        }
        failure {
            office365ConnectorSend color: '#d24146', message: "FAILED: Build #${env.BUILD_NUMBER}. GIT:${env.GIT_BRANCH}, SHA:${env.GIT_COMMIT}", status: 'FAILED',
               webhookUrl:"${TEAM_WEBHOOK}"
        }
    }
}</div>